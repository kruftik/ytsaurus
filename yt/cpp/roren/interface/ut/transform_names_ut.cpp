#include <yt/cpp/roren/interface/roren.h>
#include <yt/cpp/roren/interface/private/dummy_pipeline.h>

#include <library/cpp/testing/gtest/gtest.h>

namespace NRoren {

////////////////////////////////////////////////////////////////////////////////

// Dummy pipeline. Pipeline that is never meant to run graphs but only construct them.

std::set<TString> GetPipelineNames(const TPipeline& pipeline)
{
    class TVisitor : public NPrivate::IRawPipelineVisitor
    {
    public:
        std::set<TString> Names;

    public:
        void OnTransform(NPrivate::TTransformNode* transform)
        {
            Names.insert(transform->GetName());
        }
    };

    auto rawPipeline = NPrivate::GetRawPipeline(pipeline);
    TVisitor visitor;
    NPrivate::TraverseInTopologicalOrder(rawPipeline, &visitor);
    return std::move(visitor.Names);
}

TEST(TTestTransformNames, Simple)
{
    auto pipeline = NPrivate::MakeDummyPipeline();
    pipeline
        | "MeaningfulRead" >> DummyRead<int>()
        | "MeaningfulParDo" >> ParDo([] (const int& foo) {
            return foo + 1;
        })
        | "MeaningfulWrite" >> DummyWrite<int>();

    auto actual = GetPipelineNames(pipeline);
    auto expected = std::set<TString>{
        "MeaningfulRead",
        "MeaningfulParDo",
        "MeaningfulWrite",
    };
    EXPECT_EQ(actual, expected);
}

TEST(TTestTransformNames, AutoGeneratedNames)
{
    auto pipeline = NPrivate::MakeDummyPipeline();

    auto parDo = ParDo([] (const int& foo) {
            return foo + 1;
        });
    pipeline | DummyRead<int>() | parDo | parDo | parDo | DummyWrite<int>();
    pipeline | DummyRead<int>() | DummyWrite<int>();

    auto actual = GetPipelineNames(pipeline);
    auto expected = std::set<TString>{
        "Read", "ParDo", "ParDo2", "ParDo3", "Write",
        "Read2", "Write2",
    };
    EXPECT_EQ(actual, expected);
}

TEST(TTestTransformNames, AutoGeneratedNamesFlatten)
{
    auto pipeline = NPrivate::MakeDummyPipeline();

    auto parDo = ParDo([] (const int& foo) {
            return foo + 1;
        });
    auto input = pipeline | DummyRead<int>();
    auto tmp1 = input | parDo;
    auto tmp2 = input | parDo;
    std::vector{tmp1, tmp2} | Flatten() | DummyWrite<int>();
    std::vector{tmp1, tmp2} | Flatten() | DummyWrite<int>();
    std::vector{tmp1, tmp2} | "NamedFlatten" >> Flatten() | DummyWrite<int>();

    auto actual = GetPipelineNames(pipeline);
    auto expected = std::set<TString>{
        "Read",
        "ParDo", "ParDo2",
        "Flatten", "Flatten2", "NamedFlatten",
        "Write", "Write2", "Write3"
    };
    EXPECT_EQ(actual, expected);
}

class TMyCompositeTransform
    : public NPrivate::IWithAttributes
{
public:
    TString GetName() const
    {
        return "MyCompositeTransform";
    }

    TPCollection<int> ApplyTo(const TPCollection<int>& pCollection) const
    {
        auto parDo = ParDo([] (const int& value) {
            return value + 1;
        });
        return pCollection
            | "OneParDo" >> parDo
            | "TwoParDo" >> parDo;
    }

    void SetAttribute(const TString& key, const std::any& value) override
    {
        Y_UNUSED(key, value);
    }

    const std::any* GetAttribute(const TString& key) const override
    {
        Y_UNUSED(key);
        return nullptr;
    }
};

TEST(TTestTransformNames, CompositeTransformNames)
{
    auto pipeline = NPrivate::MakeDummyPipeline();

    pipeline
        | DummyRead<int>()
        | TMyCompositeTransform{}
        | TMyCompositeTransform{}
        | "Foo" >> TMyCompositeTransform{}
        | DummyWrite<int>();

    auto actual = GetPipelineNames(pipeline);
    auto expected = std::set<TString>{
        "Read",
        "MyCompositeTransform/OneParDo", "MyCompositeTransform/TwoParDo",
        "MyCompositeTransform2/OneParDo", "MyCompositeTransform2/TwoParDo",
        "Foo/OneParDo", "Foo/TwoParDo",
        "Write"
    };
    EXPECT_EQ(actual, expected);
}

////////////////////////////////////////////////////////////////////////////////

} // namespace NRoren
